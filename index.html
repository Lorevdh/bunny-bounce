<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bunny Bounce Retro</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #ffe6f0, #cceeff);
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background-color: #fff0f5;
      border: 4px dashed #ff99cc;
      cursor: default;
      user-select: none;
    }
    #gameOverOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(255, 182, 193, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      color: #660033;
      visibility: hidden;
      z-index: 10;
    }
    #restartButton {
      margin-top: 20px;
      padding: 15px 40px;
      font-size: 24px;
      background: #ff69b4;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      color: white;
      transition: background 0.3s ease;
    }
    #restartButton:hover {
      background: #ff4c9a;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="400"></canvas>

<div id="gameOverOverlay">
  Game Over!<br>
  <button id="restartButton">Restart</button>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const restartButton = document.getElementById("restartButton");

  let keys = {};
  let cameraX = 0;
  let score = 0;
  let highScore = parseInt(localStorage.getItem("bunnyHighScore")) || 0;
  let combo = 0;
  let lastPlatformLanded = null;
  let gameOver = false;

  document.addEventListener("keydown", e => keys[e.code] = true);
  document.addEventListener("keyup", e => keys[e.code] = false);

  const bunnyImage = new Image();
  bunnyImage.src = "assets/bunny1.png";
  const carrotImage = new Image();
  carrotImage.src = "assets/carrot.png";

  const carrots = [];
  const carrotSize = 70;


  const bgMusic = new Audio("assets/sounds/background-music.mp3");
  bgMusic.loop = true;
  bgMusic.volume = 0.3;

  const jumpSound = new Audio("assets/sounds/jump.mp3");
  const gameOverSound = new Audio("assets/sounds/gameover2.mp3");
  const owSound = new Audio("assets/sounds/ow.mp3");
owSound.volume = 1;


  const bunny = {
    x: 100, y: 0, width: 64, height: 64,
    velocityX: 0, velocityY: 0,
    speed: 4,
    jumpPower: -12,
    gravity: 0.6,
    onGround: false,
    hasJumped: false
  };

  const platforms = [];
  const cacti = [];
  const cactusWidth = 20;
  const cactusHeight = 40;

  let lastPlatformX = 0;
  let lastPlatformY = 330;

  let maxLives = 5;
  let currentLives = maxLives;

  const fullHeartImage = new Image();
  fullHeartImage.src = "assets/heart_full.png";

  const emptyHeartImage = new Image();
  emptyHeartImage.src = "assets/heart_empty.png";

  const clouds = [];

  let musicOn = true;
  let effectsOn = true;

  const iconSize = 40;
  const padding = 12;

  const musicIconBox = {
    x: canvas.width - padding - iconSize * 2 - 12,
    y: padding,
    width: iconSize,
    height: iconSize
  };

  const effectsIconBox = {
    x: canvas.width - padding - iconSize,
    y: padding,
    width: iconSize,
    height: iconSize
  };

  function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height);
    ctx.lineTo(x, y + height);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  function drawMusicIcon(ctx, x, y, size, enabled) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size / 40, size / 40);
    ctx.lineWidth = 3;
    ctx.strokeStyle = enabled ? "#ff3399" : "#ccc";
    ctx.fillStyle = enabled ? "#ff3399" : "#ccc";

    ctx.beginPath();
    ctx.moveTo(10, 35);
    ctx.lineTo(10, 10);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(10, 10);
    ctx.bezierCurveTo(10, 0, 30, 0, 30, 10);
    ctx.bezierCurveTo(30, 18, 15, 18, 10, 22);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(10, 35, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawSpeakerIcon(ctx, x, y, size, enabled) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size / 40, size / 40);
    ctx.lineWidth = 3;
    ctx.strokeStyle = enabled ? "#ff3399" : "#ccc";
    ctx.fillStyle = enabled ? "#ff3399" : "#ccc";

    ctx.beginPath();
    ctx.moveTo(8, 15);
    ctx.lineTo(18, 15);
    ctx.lineTo(26, 7);
    ctx.lineTo(26, 33);
    ctx.lineTo(18, 25);
    ctx.lineTo(8, 25);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    if (enabled) {
      ctx.beginPath();
      ctx.arc(30, 20, 6, -Math.PI / 4, Math.PI / 4);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(34, 20, 10, -Math.PI / 4, Math.PI / 4);
      ctx.stroke();
    } else {
      ctx.strokeStyle = "red";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(12, 12);
      ctx.lineTo(28, 28);
      ctx.moveTo(28, 12);
      ctx.lineTo(12, 28);
      ctx.stroke();
    }

    ctx.restore();
  }

  function generateClouds(count = 10) {
    clouds.length = 0;
    for (let i = 0; i < count; i++) {
      clouds.push({
        x: Math.random() * canvas.width * 2,
        y: Math.random() * 180,
        scale: 0.4 + Math.random() * 1.2,
        speed: 0.02 + Math.random() * 0.06,
        type: Math.floor(Math.random() * 3),
        opacity: 0.6 + Math.random() * 0.4
      });
    }
  }

  function drawCloudShape(x, y, scale = 1, type = 0, opacity = 0.8) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.fillStyle = `rgba(255,255,255,${opacity})`;
    ctx.beginPath();

    if (type === 0) {
      ctx.arc(0, 0, 30, 0, Math.PI * 2);
      ctx.arc(30, -10, 40, 0, Math.PI * 2);
      ctx.arc(70, 0, 30, 0, Math.PI * 2);
    } else if (type === 1) {
      ctx.arc(0, 10, 25, 0, Math.PI * 2);
      ctx.arc(25, 0, 35, 0, Math.PI * 2);
      ctx.arc(60, 10, 25, 0, Math.PI * 2);
    } else {
      ctx.arc(0, 0, 20, 0, Math.PI * 2);
      ctx.arc(20, -5, 30, 0, Math.PI * 2);
      ctx.arc(50, 0, 20, 0, Math.PI * 2);
    }

    ctx.fill();
    ctx.restore();
  }

  function updateClouds() {
    clouds.forEach(c => {
      const baseSpeed = 0.01 + (score / 1000);
      c.x -= c.speed * baseSpeed;

      if (c.x + 100 * c.scale < cameraX * 0.3 - 300) {
        c.x = cameraX * 0.3 + canvas.width + Math.random() * 600;
        c.y = Math.random() * 180;
        c.scale = 0.4 + Math.random() * 1.2;
        c.type = Math.floor(Math.random() * 3);
        c.opacity = 0.6 + Math.random() * 0.4;
      }
    });
  }

  function drawClouds() {
    clouds.forEach(c => {
      drawCloudShape(c.x - cameraX * 0.3, c.y, c.scale, c.type, c.opacity);
    });
  }

  function generateInitialPlatforms(count = 6) {
    platforms.length = 0;
    lastPlatformX = 0;
    lastPlatformY = 330;

    for (let i = 0; i < count; i++) {
      const width = 120 + Math.random() * 60;
      if (i > 0) {
        lastPlatformX += 160 + Math.random() * 40;
        lastPlatformY += (Math.random() - 0.5) * 40;
        lastPlatformY = Math.min(Math.max(lastPlatformY, 260), 360);
      }
      platforms.push({ x: lastPlatformX, y: lastPlatformY, width, height: 10 });

      if (platforms.length > 2 && Math.random() < 0.3) {
        const cactusX = lastPlatformX + 20 + Math.random() * (width - 40);
        cacti.push({ x: cactusX, y: lastPlatformY - cactusHeight });
      }
      if (Math.random() < 0.2) {
  const carrotX = lastPlatformX + 20 + Math.random() * (width - 40);
  carrots.push({ x: carrotX, y: lastPlatformY - carrotSize });
}

    }
  }

  function drawPlatforms() {
    ctx.fillStyle = "#add8e6";
    platforms.forEach(p => {
      ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
    });
  }

  function drawCacti() {
    cacti.forEach(c => {
      const drawX = c.x - cameraX;
      const drawY = c.y;

      ctx.fillStyle = "#228B22";
      drawRoundedRect(ctx, drawX, drawY, cactusWidth, cactusHeight, 8);

      ctx.beginPath();
      ctx.moveTo(drawX + 5, drawY + 10);
      ctx.lineTo(drawX - 8, drawY + 5);
      ctx.lineTo(drawX - 6, drawY + 15);
      ctx.lineTo(drawX + 5, drawY + 20);
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(drawX + 15, drawY + 15);
      ctx.lineTo(drawX + 28, drawY + 10);
      ctx.lineTo(drawX + 26, drawY + 20);
      ctx.lineTo(drawX + 15, drawY + 25);
      ctx.fill();
    });
  }

  function drawBunny() {
    ctx.drawImage(bunnyImage, bunny.x - cameraX, bunny.y, bunny.width, bunny.height);
  }

  function checkCollision(prevY) {
    bunny.onGround = false;
    platforms.forEach(p => {
      const bunnyBottomNow = bunny.y + bunny.height;
      const bunnyBottomPrev = prevY + bunny.height;
      const horizontalOverlap = bunny.x < p.x + p.width && bunny.x + bunny.width > p.x;
      const verticalPassThrough = bunnyBottomPrev <= p.y && bunnyBottomNow >= p.y;

      if (horizontalOverlap && verticalPassThrough && bunny.velocityY >= 0) {
        if (lastPlatformLanded !== p) {
          if (bunny.hasJumped) {
            score += 1 + combo;
            combo += 1;
            bunny.hasJumped = false;
          } else {
            combo = 0;
          }
          lastPlatformLanded = p;
        }
        bunny.velocityY = 0;
        bunny.y = p.y - bunny.height;
        bunny.onGround = true;
      }
    });
  }

  function generateNewPlatform() {
    const width = 120 + Math.random() * 60;
    lastPlatformX += 160 + Math.random() * 40;
    lastPlatformY += (Math.random() - 0.5) * 40;
    lastPlatformY = Math.min(Math.max(lastPlatformY, 260), 360);
    platforms.push({ x: lastPlatformX, y: lastPlatformY, width, height: 10 });

    if (Math.random() < 0.3) {
      const cactusX = lastPlatformX + 20 + Math.random() * (width - 40);
      cacti.push({ x: cactusX, y: lastPlatformY - cactusHeight });
    }
    if (Math.random() < 0.1) {
  const carrotX = lastPlatformX + 20 + Math.random() * (width - 40);
  carrots.push({ x: carrotX, y: lastPlatformY - carrotSize });
}

  }

  function updateBunny() {
    if (gameOver) return;

    if (keys["ArrowRight"] || keys["KeyD"]) {
      bunny.velocityX = bunny.speed;
    } else if (keys["ArrowLeft"] || keys["KeyA"]) {
      bunny.velocityX = -bunny.speed;
    } else {
      bunny.velocityX = 0;
    }

    if ((keys["ArrowUp"] || keys["KeyW"] || keys["Space"]) && bunny.onGround) {
      bunny.velocityY = bunny.jumpPower;
      bunny.onGround = false;
      bunny.hasJumped = true;
      if (effectsOn) {
        jumpSound.currentTime = 0;
        jumpSound.play();
      }
    }

    bunny.velocityY += bunny.gravity;

    const prevY = bunny.y;
    bunny.x += bunny.velocityX;
    bunny.y += bunny.velocityY;

    if (bunny.x < 0) bunny.x = 0;
    if (bunny.x + bunny.width > cameraX + canvas.width) {
      bunny.x = cameraX + canvas.width - bunny.width;
    }

    checkCollision(prevY);

   cacti.forEach(c => {
  if (
    bunny.x + bunny.width > c.x &&
    bunny.x < c.x + cactusWidth &&
    bunny.y + bunny.height > c.y &&
    bunny.y < c.y + cactusHeight
  ) {
    if (effectsOn) {
      owSound.currentTime = 0;
      owSound.play();
    }

    currentLives--;
    if (currentLives <= 0) {
      endGame();
    }
    c.x = -9999;
  }
});
for (let i = carrots.length - 1; i >= 0; i--) {
  const c = carrots[i];
  if (
    bunny.x + bunny.width > c.x &&
    bunny.x < c.x + carrotSize &&
    bunny.y + bunny.height > c.y &&
    bunny.y < c.y + carrotSize
  ) {
    if (currentLives < maxLives) {
      currentLives++;
    }
    carrots.splice(i, 1);
  }
}



    if (bunny.y > canvas.height + 100) {
      endGame();
    }

    if (bunny.x - cameraX > canvas.width * 0.6) {
      cameraX = bunny.x - canvas.width * 0.6;
    }

    while (lastPlatformX < cameraX + canvas.width + 200) {
      generateNewPlatform();
    }
  }

function drawHearts() {
  const heartSize = 32;
  const spacing = 10;
  const totalWidth = maxLives * heartSize + (maxLives - 1) * spacing;
  const startX = canvas.width / 2 - totalWidth / 2; // gecentreerd

  const y = 10; // dichter bij de bovenkant

  for (let i = 0; i < maxLives; i++) {
    const x = startX + i * (heartSize + spacing);
    const image = i < currentLives ? fullHeartImage : emptyHeartImage;
    ctx.drawImage(image, x, y, heartSize, heartSize);
  }
}
function drawCarrots() {
  carrots.forEach(c => {
    ctx.drawImage(carrotImage, c.x - cameraX, c.y, carrotSize, carrotSize);
  });
}




  function drawHUD() {
    ctx.fillStyle = "#990033";
    ctx.font = "20px monospace";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${score}`, 10, 25);
    ctx.fillText(`High Score: ${highScore}`, 10, 50);
    ctx.fillText(`Combo: ${combo}`, 10, 75);
    drawMusicIcon(ctx, musicIconBox.x, musicIconBox.y, iconSize, musicOn);
    drawSpeakerIcon(ctx, effectsIconBox.x, effectsIconBox.y, iconSize, effectsOn);
    drawHearts();
  }

  function clearScreen() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function gameLoop() {
    clearScreen();
    updateClouds();
    drawClouds();
    updateBunny();
    drawPlatforms();
    drawCacti();
    drawCarrots();
    drawBunny();
    drawHUD();

    if (!gameOver) {
      requestAnimationFrame(gameLoop);
    }
  }

  function endGame() {
    if (!gameOver) {
      gameOver = true;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("bunnyHighScore", highScore);
      }
      if (effectsOn) gameOverSound.play();
      gameOverOverlay.style.visibility = "visible";
      bgMusic.pause();
    }
  }

  restartButton.addEventListener("click", () => {
    gameOverOverlay.style.visibility = "hidden";
    resetGame();
  });

  function resetGame() {
    gameOver = false;
    score = 0;
    combo = 0;
    lastPlatformLanded = null;
    bunny.x = 100;
    bunny.y = 0;
    bunny.velocityX = 0;
    bunny.velocityY = 0;
    cameraX = 0;
    cacti.length = 0;
    currentLives = maxLives;
    carrots.length = 0;


    generateInitialPlatforms();
    generateClouds();
    bgMusic.currentTime = 0;
    if (musicOn) bgMusic.play();
    gameLoop();
  }

  canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    if (
      clickX >= musicIconBox.x && clickX <= musicIconBox.x + musicIconBox.width &&
      clickY >= musicIconBox.y && clickY <= musicIconBox.y + musicIconBox.height
    ) {
      musicOn = !musicOn;
      if (musicOn) bgMusic.play();
      else bgMusic.pause();
    }

    if (
      clickX >= effectsIconBox.x && clickX <= effectsIconBox.x + effectsIconBox.width &&
      clickY >= effectsIconBox.y && clickY <= effectsIconBox.y + effectsIconBox.height
    ) {
      effectsOn = !effectsOn;
    }
  });

  bunnyImage.onload = () => {
    generateInitialPlatforms();
    generateClouds();
    if (musicOn) bgMusic.play();
    gameLoop();
  };
</script>

</body>
</html>
 