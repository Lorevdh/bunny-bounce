<!DOCTYPE html>
<html>
<head>
  <title>Bunny Bounce Retro</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #ffe6f0, #cceeff);
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background-color: #fff0f5;
      border: 4px dashed #ff99cc;
    }
    #gameOverOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(255, 182, 193, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      color: #660033;
      visibility: hidden;
      z-index: 10;
    }
    #restartButton {
      margin-top: 20px;
      padding: 15px 40px;
      font-size: 24px;
      background: #ff69b4;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      color: white;
      transition: background 0.3s ease;
    }
    #restartButton:hover {
      background: #ff4c9a;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div id="gameOverOverlay">
    Game Over!<br>
    <button id="restartButton">Restart</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gameOverOverlay = document.getElementById("gameOverOverlay");
    const restartButton = document.getElementById("restartButton");

    let keys = {};
    let cameraX = 0;
    let score = 0;
    let highScore = parseInt(localStorage.getItem("bunnyHighScore")) || 0;
    let combo = 0;
    let lastPlatformLanded = null;
    let gameOver = false;

    document.addEventListener("keydown", e => keys[e.code] = true);
    document.addEventListener("keyup", e => keys[e.code] = false);

    const bunnyImage = new Image();
    bunnyImage.src = "assets/bunny1.png";

    const bunny = {
      x: 100, y: 0, width: 64, height: 64,
      velocityX: 0, velocityY: 0,
      speed: 4,
      jumpPower: -12,
      gravity: 0.6,
      onGround: false,
      hasJumped: false
    };

    const platforms = [];
    let lastPlatformX = 0;
    let lastPlatformY = 330;

    const clouds = [];

    function generateClouds(count = 10) {
      clouds.length = 0;
      for (let i = 0; i < count; i++) {
        clouds.push({
          x: Math.random() * canvas.width * 2,
          y: Math.random() * 180,
          scale: 0.4 + Math.random() * 1.2,
          speed: 0.02 + Math.random() * 0.06,
          type: Math.floor(Math.random() * 3),
          opacity: 0.6 + Math.random() * 0.4
        });
      }
    }

    function drawCloudShape(x, y, scale = 1, type = 0, opacity = 0.8) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.fillStyle = `rgba(255,255,255,${opacity})`;
      ctx.beginPath();

      if (type === 0) {
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.arc(30, -10, 40, 0, Math.PI * 2);
        ctx.arc(70, 0, 30, 0, Math.PI * 2);
      } else if (type === 1) {
        ctx.arc(0, 10, 25, 0, Math.PI * 2);
        ctx.arc(25, 0, 35, 0, Math.PI * 2);
        ctx.arc(60, 10, 25, 0, Math.PI * 2);
      } else {
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.arc(20, -5, 30, 0, Math.PI * 2);
        ctx.arc(50, 0, 20, 0, Math.PI * 2);
      }

      ctx.fill();
      ctx.restore();
    }



function updateClouds() {
  clouds.forEach(c => {
    const baseSpeed = 0.01 + (score / 1000);
    c.x -= c.speed * baseSpeed;

    if (c.x + 100 * c.scale < cameraX * 0.3 - 300) {
      c.x = cameraX * 0.3 + canvas.width + Math.random() * 600;
      c.y = Math.random() * 180;
      c.scale = 0.4 + Math.random() * 1.2;
      c.type = Math.floor(Math.random() * 3);
      c.opacity = 0.6 + Math.random() * 0.4;
    }
  });
}



    function drawClouds() {
      clouds.forEach(c => {
        drawCloudShape(c.x - cameraX * 0.3, c.y, c.scale, c.type, c.opacity);
      });
    }

    function generateInitialPlatforms(count = 6) {
      platforms.length = 0;
      lastPlatformX = 0;
      lastPlatformY = 330;

      for (let i = 0; i < count; i++) {
        const width = 120 + Math.random() * 60;
        if (i > 0) {
          lastPlatformX += 160 + Math.random() * 40;
          lastPlatformY += (Math.random() - 0.5) * 40;
          lastPlatformY = Math.min(Math.max(lastPlatformY, 260), 360);
        }
        platforms.push({ x: lastPlatformX, y: lastPlatformY, width, height: 10 });
      }
    }

    function drawPlatforms() {
      ctx.fillStyle = "#add8e6";
      platforms.forEach(p => {
        ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
      });
    }

    function drawBunny() {
      ctx.drawImage(bunnyImage, bunny.x - cameraX, bunny.y, bunny.width, bunny.height);
    }

    function checkCollision(prevY) {
      bunny.onGround = false;

      platforms.forEach(p => {
        const bunnyBottomNow = bunny.y + bunny.height;
        const bunnyBottomPrev = prevY + bunny.height;

        const horizontalOverlap = bunny.x < p.x + p.width && bunny.x + bunny.width > p.x;
        const verticalPassThrough = bunnyBottomPrev <= p.y && bunnyBottomNow >= p.y;

        if (horizontalOverlap && verticalPassThrough && bunny.velocityY >= 0) {
          if (lastPlatformLanded !== p) {
            if (bunny.hasJumped) {
              score += 1 + combo;
              combo += 1;
              bunny.hasJumped = false;
            } else {
              combo = 0;
            }
            lastPlatformLanded = p;
          }

          bunny.velocityY = 0;
          bunny.y = p.y - bunny.height;
          bunny.onGround = true;
        }
      });
    }

    function generateNewPlatform() {
      const width = 120 + Math.random() * 60;
      lastPlatformX += 160 + Math.random() * 40;
      lastPlatformY += (Math.random() - 0.5) * 40;
      lastPlatformY = Math.min(Math.max(lastPlatformY, 260), 360);
      platforms.push({ x: lastPlatformX, y: lastPlatformY, width, height: 10 });
    }

    function update() {
      if (gameOver) return;

      const prevY = bunny.y;

      if (keys["ArrowRight"]) {
        bunny.velocityX = bunny.speed;
      } else if (keys["ArrowLeft"]) {
        bunny.velocityX = -bunny.speed;
      } else {
        bunny.velocityX *= 0.8;
        if (Math.abs(bunny.velocityX) < 0.1) bunny.velocityX = 0;
      }

      bunny.x += bunny.velocityX;
      bunny.velocityY += bunny.gravity;
      bunny.y += bunny.velocityY;

      if (keys["Space"] && bunny.onGround) {
        bunny.velocityY = bunny.jumpPower;
        bunny.onGround = false;
        bunny.hasJumped = true;
      }

      checkCollision(prevY);

      const cameraFollowX = canvas.width * 0.4;
      if (bunny.x - cameraX > cameraFollowX) {
        cameraX = bunny.x - cameraFollowX;
      }

      for (let i = platforms.length - 1; i >= 0; i--) {
        if (platforms[i].x + platforms[i].width < cameraX - 100) {
          platforms.splice(i, 1);
          generateNewPlatform();
        }
      }

      updateClouds();

      if (bunny.y > canvas.height) {
        showGameOver();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawClouds();
      drawPlatforms();
      drawBunny();

      ctx.fillStyle = "#333";
      ctx.font = "16px monospace";
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("High Score: " + highScore, 10, 40);
      ctx.fillText("Combo: " + combo, 10, 60);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function showGameOver() {
      gameOver = true;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("bunnyHighScore", highScore);
      }
      gameOverOverlay.style.visibility = "visible";
    }

    function resetGame() {
      gameOver = false;
      score = 0;
      combo = 0;
      lastPlatformLanded = null;
      cameraX = 0;

      generateInitialPlatforms();
      generateClouds();

      const firstPlatform = platforms[0];
      bunny.x = firstPlatform.x + 10;
      bunny.y = firstPlatform.y - bunny.height;
      bunny.velocityX = 0;
      bunny.velocityY = 0;
      bunny.onGround = true;
      bunny.hasJumped = false;

      gameOverOverlay.style.visibility = "hidden";
    }

    restartButton.addEventListener("click", resetGame);

    resetGame();
    gameLoop();
  </script>
</body>
</html>
